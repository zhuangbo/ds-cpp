---
title: 数据结构
subtitle: CH2 线性表
author:
  - 滨州学院　庄波
date: 

theme: beige
## black white league beige sky
## night serif simple solarized
---

## 目标要求

- 掌握线性表的类型定义；
- 熟练掌握顺序表的表示、基本操作和算法实现；
- 熟练掌握链表的表示、基本操作和算法实现。

# 2.1 线性表的类型定义


## 线性结构

线性结构的特点
  ~ “第一个”
  ~ “最后一个”
  ~ **前驱**
  ~ **后继**

![](images/ch01/2.svg)

- - -

线性表
  ~ $n$ 个数据元素的有限序列


线性表的长度
  ~ 线性表中元素的个数 $n$ ($n \ge 0$)


空表
  ~ 长度为零的线性表

位序
  ~ 元素 $a_i$ 在表 $(a_1, a_2, \ldots, a_n)$ 中的位置 $i$

## 线性表 ADT

  - 数据对象：相同类型的 $n$ 个数据元素的集合
  - 数据关系：前驱、后继关系的集合
  - 基本操作：......

- - -

基本操作

> - **InitList(&L)** 构造空的线性表
  - **DestroyList(&L)** 销毁线性表
  - **ClearList(&L)** 清空线性表
  - **ListEmpty(L)** 判断线性表是否为空
  - **ListLength(L)** 返回线性表的长度
  - **GetElem(L,i,&e)** 取元素
  - **LocateElem(L,e,compare)** 元素定位
  - **ListInsert(&L,i,e)** 插入元素
  - **ListDelete(&L,i,&e)** 删除元素
  - **ListTraverse(L,visit)** 遍历线性表

## 线性表的应用

  - 例2-1：求集合的并集 $A\Leftarrow A \cup B$

````c++
/// 将所有在线性表 Lb 中但不在 La 中的数据元素插入到 La 中
void union(List& La, List Lb)
{
  for(i=1; i<=ListLength(Lb); i++) {
    GetElem(Lb,i,e);
    if(!LocateElem(La,e,equal))
      ListInsert(La,ListLength(La)+1,e);
  }
}
````

. . .

时间复杂度： $O(n_a \times n_b)$

- - -

  - 例2-2：归并有序表

> 问题描述：线性表 la 和 lb 中的数据元素按值非递减有序排列，要求将 la 和 lb **归并**成一个新的线性表 lc，且 lc 中的数据元素仍按值非递减有序排列。

. . .

  - 算法思路：
    1) 创建新表 lc
    2) 同时遍历线性表 La 和 lb，将较小的元素插入新表 lc 末尾
    3) 若表 la 或 lb 有剩余元素，则逐个插入表 lc 末尾

- - -

````c++
/// 将非递减有序的线性表 la 和 lb 归并到新的线性表 lc 中，保持非递减有序
void MergeList(List la, List lb, List& lc)
{
  // 创建线性表 lc
  InitList(lc);
  // 同时遍历线性表 La 和 lb，将较小的元素插入新表 lc 末尾
  i = j = k = 1;
  na = ListLength(la); nb = ListLength(lb);
  while( i<=na && j<=nb ) {
    GetElem(la,i,ai); GetElem(lb,j,bj);
    if(ai<=bj) { ListInsert(lc,k,ai); ++k; ++i; }
    else { ListInsert(lc,k,bj); ++k; ++j; }
  }
  // 剩余元素逐个插入表 lc 末尾
  while( i<=na ) {
    GetElem(la,i,ai); ListInsert(lc,k,ai); ++k; ++i;
  }
  while( j<=nb ) {
    GetElem(lb,j,bj); ListInsert(lc,k,bj); ++k; ++j;
  }
}
````

. . .

时间复杂度： $O(n_a+n_b)$


# 2.2 线性表的顺序表示和实现

## 顺序表

顺序表
  ~ 线性表的顺序存储结构
  ~ 存储特点：a）逻辑上相邻的元素在物理位置上也是相邻的，b）随机存取。

## 顺序表的类型定义

````c++
// 顺序表类型定义
struct SqList {
    T elem[MAXSIZE];  // 存储数据元素的空间
    int length;  // 当前长度
};
````

. . .

````c++
// 顺序表类型定义（用 C++ 模板实现）
template<typename T, int MAXSIZE>
struct SqList {
    T elem[MAXSIZE];  // 存储数据元素的空间
    int length;  // 当前长度
};
````

## 顺序表的基本形态

  - 表空： L.length==0，无法删除
  - 表满： L.length==MAXSIZE，无法插入
  - 非空（非满）：可以插入和删除


![](images/ch02/sqlist.png)


## 顺序表基本操作的实现

  - InitList(&L)

````c++
void InitList(SqList& L) {
    L.length = 0;  // 空表长度为 0
}
````

  - ClearList(&L)

````c++
void ClearList(SqList& L)
{
    L.length = 0;
}
````

- - -

  - ListLength(L)

````c++
int ListLength(const SqList& L)
{
    return L.length;
}
````

  - ListEmpty(L)

````c++
bool ListEmpty(const SqList& L)
{
    return L.length == 0;
}
````

- - -

- GetElem(L,i,&e)


````c++
bool GetElem(const SqLis& L, int i, T& e)
{
    // 若 i 值不合法，则返回 false
    if(i<1 || i>L.length)  return false;

    // 取第 i 个元素
    e = L.elem[i-1];

    // 返回 true 表示操作成功
    return true;
}

// 另一种实现
T GetElem(const SqList<T,M>& L, int i)
{
    // 若 i 值不合法，不能取元素
    if(i<1 || i>L.length) throw out_of_range("i out of range");

    // 返回第 i 个元素
    return L.elem[i-1];
}
````

## 插入元素 ListInsert(&L,i,e)

问题描述：

算法思路：



- - -

算法实现：

````c++
void ListInsert(SqList& L, int i, T e)
{
    // 若表满，则不能插入
    if(L.length==MAXSIZE) throw length_error("L is full");
    // 若 i 值不合法，则不能插入
    if(i<1 || i>L.length+1) throw out_of_range("i out of range");

    // 插入位置及之后的元素后移
    for(int j=L.length-1; j>=i-1; j--) {
        L.elem[j+1] = L.elem[j];
    }
    // 插入元素
    L.elem[i-1] = e;
    // 表长增 1
    L.length++;
}
````

---
###### SETTINGS ######
#revealjs-url: https://cdn.bootcss.com/reveal.js/3.4.1
math: |
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({showMathMenu:false,
  TeX:{equationNumbers:{autoNumber:'AMS'}}});
  </script>
  <script type="text/javascript" async 
  src="MathJax/MathJax.js?config=TeX-AMS_HTML">
  </script>
---
